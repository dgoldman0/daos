<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Uniswap V3 Positions on Arbitrum</title>
    <script src="https://cdn.jsdelivr.net/gh/ethereum/web3.js@1.5.3/dist/web3.min.js"></script>
</head>
<body>
    <h1>Uniswap V3 Positions on Arbitrum</h1>
    <label for="address">Enter your wallet address:</label>
    <input type="text" id="address" placeholder="0x...">
    <button id="fetchButton">Fetch Positions</button>
    
    <div id="output-summary"></div>
    <div id="output-positions"></div>
    <div id="output-aggregated"></div>

    <script>
        let web3;

        window.addEventListener('load', async () => {
            if (typeof window.ethereum !== 'undefined') {
                web3 = new Web3(window.ethereum);
                try {
                    // Request account access if needed
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                } catch (error) {
                    console.error("User denied account access", error);
                }
            } else {
                alert('MetaMask is required to use this feature. Please install MetaMask.');
            }
        });

        document.getElementById('fetchButton').addEventListener('click', fetchPositions);

        // Uniswap V3 NFT contract address on Arbitrum
        const uniswapV3NFTAddress = '0xC36442b4a4522E871399CD717aBDD847Ab11FE88';
        
        // Pool ABI
        const poolAbi = [
            {
                "inputs": [{"internalType": "uint256", "name": "tokenId", "type": "uint256"}],
                "name": "positions",
                "outputs": [
                    {"internalType": "uint96", "name": "nonce", "type": "uint96"},
                    {"internalType": "address", "name": "operator", "type": "address"},
                    {"internalType": "address", "name": "token0", "type": "address"},
                    {"internalType": "address", "name": "token1", "type": "address"},
                    {"internalType": "uint24", "name": "fee", "type": "uint24"},
                    {"internalType": "int24", "name": "tickLower", "type": "int24"},
                    {"internalType": "int24", "name": "tickUpper", "type": "int24"},
                    {"internalType": "uint128", "name": "liquidity", "type": "uint128"},
                    {"internalType": "uint256", "name": "feeGrowthInside0LastX128", "type": "uint256"},
                    {"internalType": "uint256", "name": "feeGrowthInside1LastX128", "type": "uint256"},
                    {"internalType": "uint128", "name": "tokensOwed0", "type": "uint128"},
                    {"internalType": "uint128", "name": "tokensOwed1", "type": "uint128"}
                ],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        // ERC-721 ABI (partial)
        const erc721Abi = [
            {
                "constant": true,
                "inputs": [{"name": "owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "", "type": "uint256"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [
                    {"name": "owner", "type": "address"},
                    {"name": "index", "type": "uint256"}
                ],
                "name": "tokenOfOwnerByIndex",
                "outputs": [{"name": "tokenId", "type": "uint256"}],
                "type": "function"
            }
        ];

        async function fetchPositions() {
            const address = document.getElementById("address").value;
            const outputSummary = document.getElementById("output-summary");
            const outputPositions = document.getElementById("output-positions");
            const outputAggregated = document.getElementById("output-aggregated");

            outputSummary.innerHTML = "Fetching positions...";
            outputPositions.innerHTML = "";
            outputAggregated.innerHTML = "";

            if (!web3.utils.isAddress(address)) {
                outputSummary.innerHTML = "Invalid address.";
                return;
            }

            try {
                const uniswapV3NFTContract = new web3.eth.Contract(erc721Abi, uniswapV3NFTAddress);
                const balance = await uniswapV3NFTContract.methods.balanceOf(address).call();
                let positions = [];
                let tokenBalances = {};

                for (let i = 0; i < balance; i++) {
                    const tokenId = await uniswapV3NFTContract.methods.tokenOfOwnerByIndex(address, i).call();
                    const positionDetails = await fetchPositionDetails(tokenId);

                    // Aggregate liquidity for each token
                    [positionDetails.token0, positionDetails.token1].forEach(tokenAddress => {
                        if (!tokenBalances[tokenAddress]) {
                            tokenBalances[tokenAddress] = { liquidity: 0, decimals: 0, symbol: 'Unknown' };
                        }
                        tokenBalances[tokenAddress].liquidity += parseFloat(positionDetails.liquidity);
                    });

                    positions.push(positionDetails);
                }

                // Fetch token symbols and decimals for better readability
                for (let tokenAddress in tokenBalances) {
                    tokenBalances[tokenAddress].symbol = await fetchTokenSymbol(tokenAddress);
                    tokenBalances[tokenAddress].decimals = await fetchTokenDecimals(tokenAddress);
                }

                // Update the output elements
                outputSummary.innerHTML = `Found ${positions.length} positions:`;

                outputPositions.innerHTML = positions.map(pos => `
                    <div>
                        <strong>Token ID:</strong> ${pos.tokenId}<br>
                        <strong>Token0:</strong> ${pos.token0Symbol} (${pos.token0})<br>
                        <strong>Token1:</strong> ${pos.token1Symbol} (${pos.token1})<br>
                        <strong>Liquidity:</strong> ${pos.liquidity}<br>
                        <strong>Tick Lower:</strong> ${pos.tickLower}<br>
                        <strong>Tick Upper:</strong> ${pos.tickUpper}<br>
                        <strong>Fee:</strong> ${pos.fee}
                    </div><br>
                `).join('');

                outputAggregated.innerHTML = `<h2>Total Liquidity per Token:</h2>` +
                    `<ul>` +
                    Object.keys(tokenBalances).map(tokenAddress => {
                        const formattedLiquidity = (tokenBalances[tokenAddress].liquidity / Math.pow(10, tokenBalances[tokenAddress].decimals)).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 });
                        return `
                            <li>
                                <strong>${tokenBalances[tokenAddress].symbol} (${tokenAddress}):</strong> ${formattedLiquidity}
                            </li>
                        `;
                    }).join('') +
                    `</ul>`;
            } catch (error) {
                outputSummary.innerHTML = `Error fetching positions: ${error.message}`;
            }
        }

        async function fetchPositionDetails(tokenId) {
            const uniswapV3NFTContract = new web3.eth.Contract(poolAbi, uniswapV3NFTAddress);
            try {
                const position = await uniswapV3NFTContract.methods.positions(tokenId).call();
                const token0Symbol = await fetchTokenSymbol(position.token0);
                const token1Symbol = await fetchTokenSymbol(position.token1);

                return {
                    tokenId: tokenId,
                    liquidity: position.liquidity,
                    tickLower: position.tickLower,
                    tickUpper: position.tickUpper,
                    token0: position.token0,
                    token1: position.token1,
                    token0Symbol: token0Symbol,
                    token1Symbol: token1Symbol,
                    fee: position.fee,
                };
            } catch (error) {
                console.error(`Error fetching details for tokenId ${tokenId}: ${error.message}`);
                return { tokenId, error: error.message };
            }
        }

        async function fetchTokenSymbol(tokenAddress) {
            const erc20Abi = [
                {
                    "constant": true,
                    "inputs": [],
                    "name": "symbol",
                    "outputs": [{"name": "", "type": "string"}],
                    "type": "function"
                }
            ];
            const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);
            try {
                return await tokenContract.methods.symbol().call();
            } catch (error) {
                console.error(`Error fetching symbol for token ${tokenAddress}: ${error.message}`);
                return 'Unknown';
            }
        }

        async function fetchTokenDecimals(tokenAddress) {
            const erc20Abi = [
                {
                    "constant": true,
                    "inputs": [],
                    "name": "decimals",
                    "outputs": [{"name": "", "type": "uint8"}],
                    "type": "function"
                }
            ];
            const tokenContract = new web3.eth.Contract(erc20Abi, tokenAddress);
            try {
                let res = parseInt(await tokenContract.methods.decimals().call(), 10);
                console.log(`Decimals for token ${tokenAddress}: ${res}`);
                return res;
            } catch (error) {
                console.error(`Error fetching decimals for token ${tokenAddress}: ${error.message}`);
                return 18; // Default to 18 decimals if fetching fails
            }
        }
    </script>
</body>
</html>
